<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flappy Mel√≥n üçàüç∫</title>
  <style>
    :root{--bg:#0b1020;--fg:#eef3ff;--accent:#5cf2a1;--muted:#8aa0c7;--danger:#ff6b6b}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1020 0%, #152348 70%, #1a2a55 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif;overflow:hidden}
    #game{position:fixed;inset:0;display:block}
    .hud{position:fixed;inset:0;pointer-events:none;}
    .scoreLive{position:absolute;top:14px;left:14px;background:rgba(0,0,0,.35);backdrop-filter:blur(4px);padding:.5rem .75rem;border-radius:12px;font-weight:700;letter-spacing:.5px}
    .badge{display:inline-flex;align-items:center;gap:.4rem;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.25rem .5rem;border-radius:999px;font-size:.8rem;color:var(--muted)}
    .screen{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:24px}
    .panel{pointer-events:auto;max-width:560px;width:min(92vw,680px);background:rgba(10,14,30,.7);border:1px solid rgba(255,255,255,.12);border-radius:20px;box-shadow:0 10px 40px rgba(0,0,0,.45);padding:18px}
    .panel h1{margin:.2rem 0 0;font-size:clamp(1.6rem,4vw,2.4rem);line-height:1.1}
    .panel p{color:var(--muted);margin:.4rem 0 .9rem}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .grow{flex:1}
    input,button{font:inherit}
    input[type="text"]{width:100%;padding:.75rem .9rem;border-radius:14px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06);color:var(--fg);outline:none}
    input[type="text"]:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(92,242,161,.15)}
    button{padding:.75rem 1rem;border-radius:14px;border:1px solid rgba(255,255,255,.18);background:linear-gradient(180deg,#2f855a,#276749);color:white;cursor:pointer}
    button.ghost{background:rgba(255,255,255,.06);color:var(--fg)}
    button.warn{background:linear-gradient(180deg,#b83b3b,#a12f2f)}
    .grid{display:grid;grid-template-columns:1fr auto;gap:.75rem;align-items:center}
    ol{margin:.4rem 0 0;padding-left:1.2rem}
    li{padding:.15rem 0}
    .tiny{font-size:.8rem;color:var(--muted)}
    .hidden{display:none}
    .center{text-align:center}
      .byline{font-weight:700;font-size:clamp(.9rem,2.2vw,1.1rem);color:var(--muted);margin-left:.5rem;white-space:nowrap}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud">
    <div class="scoreLive badge" id="scoreLive">Puntos: 0</div>

    <!-- Ready Screen -->
    <div id="screen-ready" class="screen">
      <div class="panel">
        <div class="row" style="justify-content:space-between;align-items:center">
          <span class="badge">Sala: <strong id="roomLabel">default</strong></span>
          <span class="badge">Tap / Clic / Espacio para saltar</span>
        </div>
        <h1>Flappy <span style="color:#9efc86">Mel√≥n</span> <span class="byline">por Coeto Games üöÄ</span></h1>
        <p>Mant√©n al mel√≥n con alas en el aire y pasa entre columnas de botellines. Partidas de 30‚Äì60s. ¬°F√°cil de aprender, cab*** de dominar!</p>
        <div class="row">
          <button id="btnStart" class="grow">Jugar</button>
          <button id="btnHow" class="ghost">C√≥mo jugar</button>
        </div>
        <div id="how" class="hidden">
          <p>Controles: pulsa para subir (o barra espaciadora). Ganas +1 punto por cada par de botellines superado. Chocar con un botell√≠n o el suelo = game over.</p>
          <p class="tiny">Consejo: los near‚Äëmiss (pasar muy justo) no dan puntos extra‚Ä¶ pero s√≠ respeto.</p>
        </div>
        <hr style="border-color:rgba(255,255,255,.1)">
        <div>
          <strong>Ranking local (top 10)</strong>
          <ol id="lbHome"></ol>
        </div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="screen-over" class="screen hidden">
      <div class="panel">
        <h1>¬°Has palmado! üí•</h1>
        <p>Tu puntuaci√≥n: <strong id="finalScore">0</strong> ‚Äî R√©cord: <strong id="bestScore">0</strong></p>
        <div class="grid" style="margin:.5rem 0 1rem">
          <input id="playerName" type="text" maxlength="18" placeholder="Tu nombre o pe√±a" />
          <button id="btnSave">Guardar</button>
        </div>
        <div class="row">
          <button id="btnRetry" class="grow">Jugar de nuevo</button>
        </div>
        <div style="margin-top:1rem">
          <strong>Ranking local (top 10)</strong>
          <ol id="lbList"></ol>
          <p class="tiny">El ranking se guarda en este dispositivo. Para un ranking compartido de evento, te dejo un hook para Supabase en el c√≥digo (opcional).
          </p>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Flappy Mel√≥n ‚Äî Juego Canvas sin dependencias
  // Autor: t√∫ + ChatGPT. Copia este archivo como index.html y √°brelo en el navegador.
  // Bonus: Usa ?room=NOMBRE en la URL para separar rankings locales por sala (ej: ?room=GUADA25)
  // Opcional (evento): ver funci√≥n postScore() para integrar con una API (p.ej. Supabase Edge Function)
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const $ = (id) => document.getElementById(id);
    const $ready = $('screen-ready');
    const $over = $('screen-over');
    const $scoreLive = $('scoreLive');
    const $finalScore = $('finalScore');
    const $bestScore = $('bestScore');
    const $lbHome = $('lbHome');
    const $lbList = $('lbList');
    const $playerName = $('playerName');
    const $roomLabel = $('roomLabel');

    const params = new URLSearchParams(location.search);
    const ROOM = (params.get('room') || 'default').toLowerCase();
    $roomLabel.textContent = ROOM;

    // Storage keys por sala
    const LB_KEY = `flapmelon_lb_${ROOM}`;
    const NAME_KEY = `flapmelon_name_${ROOM}`;

    // Mundo y escalado
    let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let GROUND_H = 0; // altura suelo visible
    let UNIT = 1; // escala base

    function resize() {
      W = window.innerWidth; H = window.innerHeight;
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      UNIT = Math.max(0.7, Math.min(1.4, Math.min(W, H) / 900));
      GROUND_H = 80 * UNIT;
    }
    resize();
    window.addEventListener('resize', () => { resize(); if(state!==STATE.PLAYING) draw(); });

    // Estado de juego
    const STATE = { READY:0, PLAYING:1, OVER:2 };
    let state = STATE.READY;

    // Jugador (mel√≥n con alas)
    const player = {
      x: 0, y: 0, r: 18, vy: 0, rot: 0, wingT: 0, lastFlapT: 0, flapCombo: 0,
      reset(){
        this.x = W*0.3; this.y = H*0.45; this.vy = 0; this.rot = 0; this.r = 18*UNIT; this.flapCombo = 0; this.lastFlapT = 0;
      },
      flap(now){
        const t = (typeof now==='number' ? now : performance.now());
        if (t - this.lastFlapT <= COMBO_WINDOW*1000) {
          this.flapCombo = Math.min(this.flapCombo + 1, MAX_COMBO);
        } else {
          this.flapCombo = 0;
        }
        this.lastFlapT = t;
        const vyTarget = FLAP_BASE + this.flapCombo * FLAP_STEP; // valores negativos
        this.vy = vyTarget;
      },
      update(dt){
        this.vy += GRAV * dt; // gravedad
        this.y += this.vy;
        this.rot = Math.atan2(this.vy, 200*UNIT); // inclinaci√≥n ligera
        this.wingT += dt*10; // anim de alas
      },
      draw(){ drawMelonWithWings(this.x, this.y, this.r, this.wingT, this.rot); }
    };

    // Obst√°culos (columnas de botellines)
    const pipes = [];
    let PIPE_W = 64;     // ancho columna
    let PIPE_GAP = 240;  // hueco
    let PIPE_SPD = 180;  // px/s
    let PIPE_SPACING = 300; // separaci√≥n horizontal

    // Flap combo y f√≠sica ajustable
    let FLAP_BASE = -3.9*UNIT, FLAP_STEP = -1.2*UNIT, MAX_COMBO = 3; // valores negativos
    const COMBO_WINDOW = 0.45; // s para encadenar toques
    const COMBO_RESET = 0.55; // s referencia (se usa en siguiente toque)
    let GRAV = 18*UNIT;

    function tuneByScale(){
      PIPE_W = 64*UNIT; PIPE_GAP = 240*UNIT; PIPE_SPD = 180*UNIT; PIPE_SPACING = 300*UNIT;
      GRAV = 18*UNIT;
      FLAP_BASE = -3.9*UNIT;
      FLAP_STEP = -1.2*UNIT;
      player.r = 18*UNIT;
    }
    tuneByScale();

    function resetPipes(){
      pipes.length = 0;
      let x = W*1.1;
      for(let i=0;i<4;i++){
        const gapY = randBetween(H*0.28, H*0.72);
        pipes.push({x, gapY, scored:false});
        x += PIPE_SPACING;
      }
    }

    function addPipeAt(x){
      const gapY = randBetween(H*0.28, H*0.72);
      pipes.push({x, gapY, scored:false});
    }

    // Puntuaci√≥n
    let score = 0; let best = 0; best = Number(localStorage.getItem(`flapmelon_best_${ROOM}`) || 0);

    // Tiempo
    let lastT = performance.now();

    // Entradas
    function onPress(){
      if(state===STATE.READY){ start(); }
      else if(state===STATE.PLAYING){ player.flap(performance.now()); }
      else if(state===STATE.OVER){ /* ignore */ }
    }
    window.addEventListener('pointerdown', (e)=>{ const el=e.target; if(el && el.closest && el.closest('.panel')) return; onPress(); });
    window.addEventListener('keydown', (e)=>{
      if(['Space','ArrowUp','KeyW'].includes(e.code)){ e.preventDefault(); onPress(); }
      if(state===STATE.OVER && e.code==='Enter'){ saveScore(); }
    });

    // Loop
    function tick(now){
      const dt = Math.min(0.032, (now - lastT) / 1000); // m√°x 32 ms
      lastT = now;
      if(state===STATE.PLAYING){ update(dt); draw(); requestAnimationFrame(tick); }
      else { draw(); requestAnimationFrame(tick); } // seguimos dibujando para animaci√≥n sutil
    }

    function start(){
      state = STATE.PLAYING; hide($ready); hide($over);
      resize(); tuneByScale(); player.reset(); resetPipes(); score = 0; updateScoreHUD();
    }

    function gameOver(){
      state = STATE.OVER; show($over); hide($ready);
      $finalScore.textContent = String(score);
      if(score>best){ best=score; localStorage.setItem(`flapmelon_best_${ROOM}`, String(best)); }
      $bestScore.textContent = String(best);
      $playerName.value = localStorage.getItem(NAME_KEY) || '';
      renderLB();
      setTimeout(() => { $playerName.focus(); }, 50);
    }

    function update(dt){
      player.update(dt);
      // mover columnas
      for(const p of pipes){ p.x -= PIPE_SPD*dt; }
      // reciclar y a√±adir nuevas
      if(pipes.length && pipes[0].x + PIPE_W < -20){ pipes.shift(); const last = pipes[pipes.length-1]; addPipeAt(last.x + PIPE_SPACING); }
      // puntuaci√≥n
      for(const p of pipes){
        if(!p.scored && player.x > p.x + PIPE_W){ p.scored = true; score++; updateScoreHUD(); }
      }
      // colisiones
      if(checkCollision()) { gameOver(); }
      // suelo
      if(player.y + player.r >= H - GROUND_H){ player.y = H - GROUND_H - player.r; gameOver(); }
    }

    function updateScoreHUD(){ $scoreLive.textContent = `Puntos: ${score}`; }

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawBackground();
      // suelo
      drawGround();
      // columnas
      for(const p of pipes){ drawColumn(p.x, 0, PIPE_W, p.gapY - PIPE_GAP/2, true); drawColumn(p.x, p.gapY + PIPE_GAP/2, PIPE_W, (H - GROUND_H) - (p.gapY + PIPE_GAP/2), false); }
      // jugador
      player.draw();
      // si estamos en start/over, quiz√° un sutil latido del mel√≥n
      if(state!==STATE.PLAYING){
        // restaura mel√≥n a posici√≥n fija
      }
    }

    // ===== Dibujo =====
    function drawBackground(){
      // capa de estrellas sutiles
      ctx.save();
      ctx.globalAlpha = 0.15;
      const step = 64*UNIT;
      for(let y=step; y<H; y+=step){
        for(let x=step; x<W; x+=step){
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(x, y, 1, 1);
        }
      }
      ctx.restore();
    }

    function drawGround(){
      const y = H - GROUND_H;
      ctx.fillStyle = '#0e1a34';
      ctx.fillRect(0, y, W, GROUND_H);
      // l√≠nea de separaci√≥n
      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      ctx.beginPath();
      ctx.moveTo(0, y+0.5);
      ctx.lineTo(W, y+0.5);
      ctx.stroke();
    }

    // Dibuja una columna con un √∫nico botell√≠n grande
    function drawColumn(x, y, w, h, top){
      if(h<=0) return;
      ctx.save();
      // fondo sutil para la zona del obst√°culo
      ctx.fillStyle = '#17325e';
      ctx.fillRect(x, y, w, h);
      // botella √∫nica, ajustada al rect√°ngulo
      const padX = Math.max(4*UNIT, w*0.12);
      const padY = Math.max(4*UNIT, h*0.06);
      const bx = x + padX, by = y + padY;
      const bw = Math.max(12*UNIT, w - padX*2);
      const bh = Math.max(24*UNIT, h - padY*2);
      drawBottleInRect(bx, by, bw, bh, top); // top = invertida
      // contorno suave
      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
      ctx.restore();
    }

    function drawBottleInRect(x, y, w, h, invert){
      ctx.save();
      // Centro del rect
      ctx.translate(x + w/2, y + h/2);
      if(invert){ ctx.rotate(Math.PI); }
      const BW = w, BH = h;
      const neckH = BH*0.28, bodyH = BH - neckH;
      const neckW = BW*0.42, bodyW = BW*0.72;
      // cuerpo √°mbar
      ctx.fillStyle = '#f2c14e';
      roundRect(ctx, -bodyW/2, -BH/2 + neckH, bodyW, bodyH, Math.max(4*UNIT, BW*0.08), true, false);
      // cuello
      ctx.fillStyle = '#d4a64c';
      roundRect(ctx, -neckW/2, -BH/2, neckW, neckH, Math.max(3*UNIT, BW*0.06), true, false);
      // chapa
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-neckW*0.35, -BH/2 - 2*UNIT, neckW*0.7, 4*UNIT);
      // etiqueta
      ctx.fillStyle = 'rgba(255,255,255,.85)';
      const labelH = bodyH*0.34; const labelY = -BH/2 + neckH + bodyH*0.38;
      roundRect(ctx, -bodyW*0.44, labelY, bodyW*0.88, labelH, Math.max(4*UNIT, BW*0.08), true, false);
      ctx.restore();
    }

    // (Antiguo) Dibujo de botella individual ‚Äî lo dejamos por si lo queremos reutilizar en el futuro
    function drawBottle(x, y, bw, bh){
      // cuerpo
      const neckH = bh*0.28, bodyH = bh-neckH, neckW = bw*0.55, bodyW = bw;
      // cuerpo √°mbar
      ctx.fillStyle = '#f2c14e';
      roundRect(ctx, x - bodyW/2, y + neckH, bodyW, bodyH, 3*UNIT, true, false);
      // cuello
      ctx.fillStyle = '#d4a64c';
      roundRect(ctx, x - neckW/2, y, neckW, neckH, 2*UNIT, true, false);
      // chapa
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x - neckW*0.4, y - 2*UNIT, neckW*0.8, 3*UNIT);
      // etiqueta
      ctx.fillStyle = 'rgba(255,255,255,.85)';
      const labelH = bodyH*0.35; const labelY = y + neckH + bodyH*0.35;
      roundRect(ctx, x - bodyW*0.4, labelY, bodyW*0.8, labelH, 3*UNIT, true, false);
    }

    function drawMelonWithWings(cx, cy, r, t, rot){
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rot*0.4);
      // alas
      const flap = Math.sin(t)*0.5 + 0.5; // 0..1
      const wingSpan = r*1.6;
      ctx.fillStyle = '#f9f9f9';
      for(const s of [-1,1]){
        ctx.save();
        ctx.scale(s,1);
        ctx.rotate((-0.6 + flap*0.9) * s);
        wingPath(wingSpan, r*0.7);
        ctx.fill();
        ctx.restore();
      }
      // cuerpo mel√≥n tipo bal√≥n de rugby (elipse)
      const rx = r*1.25, ry = r*0.9;
      const grad = ctx.createRadialGradient(0,0,r*0.3, 0,0,Math.max(rx,ry));
      grad.addColorStop(0,'#9efc86');
      grad.addColorStop(1,'#1e7d3f');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.ellipse(0,0,rx,ry,0,0,Math.PI*2); ctx.fill();
      // rayas del mel√≥n (ligeras)
      ctx.save();
      ctx.clip();
      ctx.strokeStyle = 'rgba(0,0,0,.25)';
      ctx.lineWidth = Math.max(1, r*0.12);
      for(let i=0;i<6;i++){
        ctx.beginPath();
        ctx.ellipse(0,0,rx*0.96, ry*0.96, 0, i*Math.PI/3, i*Math.PI/3 + Math.PI/14);
        ctx.stroke();
      }
      ctx.restore();
      // carita sonriente
      ctx.fillStyle = '#0b1020';
      ctx.beginPath(); ctx.arc(rx*0.35, -ry*0.1, r*0.12, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-rx*0.35, -ry*0.1, r*0.12, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#0b1020';
      ctx.lineWidth = Math.max(2, r*0.08);
      ctx.beginPath(); ctx.arc(0, ry*0.1, r*0.45, 0.15*Math.PI, 0.85*Math.PI); ctx.stroke();
      // brillo
      ctx.fillStyle = 'rgba(255,255,255,.6)';
      ctx.beginPath(); ctx.ellipse(-rx*0.35, -ry*0.3, r*0.12, r*0.09, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function wingPath(w, h){
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(w*0.2, -h*0.6, w*0.6, -h*0.2);
      ctx.quadraticCurveTo(w*0.9, 0, w*0.6, h*0.2);
      ctx.quadraticCurveTo(w*0.2, h*0.6, 0, 0);
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      if(w<2*r) r=w/2; if(h<2*r) r=h/2;
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    // ===== Colisiones =====
    function checkCollision(){
      // contra columnas
      for(const p of pipes){
        const x1 = p.x, x2 = p.x + PIPE_W;
        const gapTop = p.gapY - PIPE_GAP/2;
        const gapBotY = p.gapY + PIPE_GAP/2;
        const circleX = player.x, circleY = player.y, r = player.r;
        if(circleX + r > x1 && circleX - r < x2){
          if(circleY - r < gapTop || circleY + r > gapBotY){ return true; }
        }
      }
      // techo (opcional)
      if(player.y - player.r < 0){ player.y = player.r; player.vy = 0; }
      return false;
    }

    // ===== Leaderboard local =====
    function loadLB(){ try { return JSON.parse(localStorage.getItem(LB_KEY) || '[]'); } catch(e){ return []; } }
    function saveLB(arr){ localStorage.setItem(LB_KEY, JSON.stringify(arr.slice(0,50))); }
    function addToLB(name, score){
      const list = loadLB();
      list.push({name:name.trim().slice(0,18)||'An√≥nimo', score, ts:Date.now()});
      list.sort((a,b)=> b.score - a.score || a.ts - b.ts);
      saveLB(list);
      return list.slice(0,10);
    }
    function renderLB(){
      const list = loadLB().slice(0,10);
      const toHTML = (arr) => arr.map((e,i)=>`<li>${escapeHtml(e.name)} ‚Äî <strong>${e.score}</strong></li>`).join('');
      $lbList.innerHTML = toHTML(list);
      $lbHome.innerHTML = toHTML(list);
    }
    function escapeHtml(str){ return str.replace(/[&<>"']/g, s=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',''':'&#39;'}[s])); }

    function saveScore(){
      const name = $playerName.value || '';
      if(!name.trim()){
        $playerName.focus();
        return;
      }
      localStorage.setItem(NAME_KEY, name.trim());
      const top10 = addToLB(name, score);
      renderLB();
    }

    // ===== Integraci√≥n API (Opcional) =====
    // Rellena POST_URL con tu endpoint (por ejemplo, una Supabase Edge Function) para ranking global.
    // El body que se env√≠a: { room, name, score }
    async function postScore(name, score){
      const POST_URL = '';// ej: 'https://<tu-proyecto>.functions.supabase.co/flapmelon'
      if(!POST_URL) return; // sin configurar, no hace nada
      try{
        await fetch(POST_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({room:ROOM, name, score}) });
      }catch(err){ console.warn('No se pudo enviar el score global:', err); }
    }

    // ===== UI =====
    const btn = (id, fn) => $(id)?.addEventListener('click', (e)=>{ e.stopPropagation?.(); fn(e); });
    btn('btnStart', start);
    btn('btnRetry', ()=>{ state=STATE.READY; show($ready); hide($over); });
    btn('btnSave', saveScore);
    btn('btnHow', ()=>{ $('how').classList.toggle('hidden'); });

    function show(el){ el.classList.remove('hidden'); }
    function hide(el){ el.classList.add('hidden'); }

    // ===== Util =====
    function randBetween(a,b){ return a + Math.random()*(b-a); }

    // ===== Mini test suite (no intrusiva) =====
    function assert(name, cond){ if(cond){ console.log('‚úÖ', name); } else { console.error('‚ùå', name); } }
    function runTests(){
      try{
        // Test 1: funciones clave existen
        assert('start existe', typeof start==='function');
        assert('drawMelonWithWings existe', typeof drawMelonWithWings==='function');
        assert('wingPath existe', typeof wingPath==='function');

        // Test 2: transici√≥n READY -> PLAYING -> OVER
        const prevState = state;
        start(); assert('state = PLAYING tras start()', state===STATE.PLAYING);
        gameOver(); assert('state = OVER tras gameOver()', state===STATE.OVER);
        state = prevState; hide($over); show($ready);

        // Test 3: leaderboard ordena por score desc
        const backup = localStorage.getItem(LB_KEY);
        localStorage.setItem(LB_KEY, '[]');
        addToLB('B', 2); addToLB('A', 10); addToLB('C', 7);
        const list = loadLB();
        assert('leaderboard top = 10', list[0]?.score===10);
        if(backup!==null) localStorage.setItem(LB_KEY, backup); else localStorage.removeItem(LB_KEY);

        // Test 4: draw no lanza
        try { draw(); assert('draw() no lanza', true); } catch(e){ assert('draw() no lanza', false); }
      }catch(e){ console.error('Tests error:', e); }
    }

    // Init
    player.reset(); renderLB(); draw(); requestAnimationFrame((t)=>{ lastT=t; tick(t); });
    runTests();
  })();
  </script>
</body>
</html>
